
'use strict';

//
// AnalysisDocument.js
// Analysis workflow document
//
// VDJServer Analysis Portal
// VDJ API Service
// https://vdjserver.org
//
// Copyright (C) 2020-2021 The University of Texas Southwestern Medical Center
//
// Author: Scott Christley <scott.christley@utsouthwestern.edu>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

var config = require('../config/config');
var vdj_schema = require('vdjserver-schema');

// cache the schema definition
var schema;

var _ = require('underscore');

var AnalysisDocument = function(document) {
    if (!schema) schema = new vdj_schema.SchemaDefinition('AnalysisDocument');

    // create template from schema
    let doc = schema.template();
    for (let p in doc) {
        this[p] = doc[p];
    }

    // deep copy of attributes
    for (let p in document) {
        this[p] = JSON.parse(JSON.stringify(document[p]));
    }
};
module.exports = AnalysisDocument;

var tapisV2 = require('vdj-tapis-js/tapis');
var tapisV3 = require('vdj-tapis-js/tapisV3');
var tapisIO = null;
if (config.tapis_version == 2) tapisIO = tapisV2;
if (config.tapis_version == 3) tapisIO = tapisV3;

AnalysisDocument.prototype.get_input_entities = function() {
    var inputs = {};

    // input entities are ones that are not generated by an activity
    for (let e in this.entity) {
        let is_input = true;
        for (let g in this.isGeneratedBy) {
            if (this.isGeneratedBy[g]['prov:entity'] == e) {
                is_input = false;
                break;
            }
        }

        if (is_input) inputs[e] = this.entity[e];
    }

    return inputs;
}

AnalysisDocument.prototype.get_available_entities = function() {
    var available = this.get_input_entities();

    for (let e in this.entity) {
        // also, an entity that wasGeneratedBy by an activity which has finished
        let is_available = true;
        for (let w in this.wasGeneratedBy) {
            if ((this.wasGeneratedBy[w]['prov:entity'] == e)
                && (this.activity[this.wasGeneratedBy[w]['prov:activity']]['prov:endTime'])) {
                    is_available = true;
                    break;
                }
        }

        if (is_available) available[e] = this.entity[e];
    }

    return available;
}

// find set of activities which can be performed based on inputs
AnalysisDocument.prototype.perform_activities = function(is_executing) {
    var context = 'AnalysisDocument.perform_activities';
    var activities = {};
    var activity_uses = {};
    var inputs = this.get_available_entities();

    // get set of activities where all inputs are available
    for (let a in this.activity) {
        if (this.activity[a]['prov:startTime']) continue;
        let found_all = true;
        for (let u in this.uses) {
            if (this.uses[u]['prov:activity'] == a) {
                if (inputs[this.uses[u]['prov:entity']]) {
                    if (! activity_uses[a]) activity_uses[a] = [];
                    activity_uses[a].push(u);
                } else {
                    found_all = false;
                    if (activity_uses[a]) delete activity_uses[a];
                    break;
                }
            }
        }
        if (found_all) activities[a] = this.activity[a];
    }
    config.log.info(context, 'performing activities: ' + JSON.stringify(activities, null, 2));
    config.log.info(context, 'activity uses: ' + JSON.stringify(activity_uses, null, 2));

    // no activities to perform
    if (Object.keys(activities).length == 0) return null;

    if (!this.used) this.used = {};
    if (!this.wasGeneratedBy) this.wasGeneratedBy = {};

    if (is_executing) {
        // execute activities
    } else {
        // simulate execution
        for (let a in activities) {
            this.activity[a]['prov:startTime'] = new Date().toISOString();
            for (let u in activity_uses[a])
                this.used[activity_uses[a][u]] = this.uses[activity_uses[a][u]];
            for (let g in this.isGeneratedBy) {
                if (this.isGeneratedBy[g]['prov:activity'] == a)
                    this.wasGeneratedBy[g] = this.isGeneratedBy[g];
            }
            this.activity[a]['prov:endTime'] = new Date().toISOString();
        }
    }

    return activities;
}

AnalysisDocument.prototype.validate = async function(project_uuid, allow_alternate) {
    var context = 'AnalysisDocument.validate';
    var valid = true;

    // TODO: need to return reasons/messages for anything invalid

    // check that all the uses relationships can be resolved
    for (let u in this.uses) {
        if (! this.uses[u]['prov:activity']) valid = false;
        else if (! this.activity[this.uses[u]['prov:activity']]) valid = false;

        if (! this.uses[u]['prov:entity']) valid = false;
        else if (! this.entity[this.uses[u]['prov:entity']]) valid = false;
    }

    // check that all the isGeneratedBy relationships can be resolved
    for (let u in this.isGeneratedBy) {
        if (! this.isGeneratedBy[u]['prov:activity']) valid = false;
        else if (! this.activity[this.isGeneratedBy[u]['prov:activity']]) valid = false;

        if (! this.isGeneratedBy[u]['prov:entity']) valid = false;
        else if (! this.entity[this.isGeneratedBy[u]['prov:entity']]) valid = false;
    }

    // validate that activities are tapis app ids
    for (let a in this.activity) {
        if (this.activity[a]['vdjserver:app']) {
            let app = await tapisIO.getApplication(this.activity[a]['vdjserver:app'])
                .catch(function(error) {
                    return Promise.reject(error);
                });
            if (app['statusCode'] == 404) {
                if (allow_alternate) {
                    // TODO: check alternates
                }
                valid = false;
            } else
                config.log.info(context, 'vdjserver:app (' + this.activity[a]['vdjserver:app'] + ') exists.');

                // check that inputs can be resolved to entity attributes
                for (let i in app['inputs']) {
                    // ok if has non-blank default value or is not required
                    if ((app['inputs'][i]['value']['default'])
                        && (app['inputs'][i]['value']['default'].length > 0)) continue;
                    if (app['inputs'][i]['value']['required']) continue;

                    let found = false;
                    for (let u in this.uses) {
                        if (this.uses[u]['prov:activity'] == a)
                            if (this.entity[this.uses[u]['prov:entity']]['vdjserver:type'] == 'app:inputs')
                                if (this.entity[this.uses[u]['prov:entity']][app['inputs'][i]['id']]) {
                                    found = true;
                                    break;
                                }
                    }
                    if (!found) valid = false;
                }

                // check that parameters can be resolved to entity attributes
                for (let i in app['parameters']) {
                    // ok if has non-blank default value or is not required
                    if ((app['parameters'][i]['value']['default'])
                        && (app['parameters'][i]['value']['default'].length > 0)) continue;
                    if (app['parameters'][i]['value']['required']) continue;

                    let found = false;
                    for (let u in this.uses) {
                        if (this.uses[u]['prov:activity'] == a)
                            if (this.entity[this.uses[u]['prov:entity']]['vdjserver:type'] == 'app:parameters')
                                if (this.entity[this.uses[u]['prov:entity']][app['parameters'][i]['id']]) {
                                    found = true;
                                    break;
                                }
                    }
                    if (!found) valid = false;
                }
        }
    }

    if (!valid) return Promise.resolve(valid);

    // determine input files, validate their existence
    var inputs = this.get_input_entities();
    console.log(inputs);
    for (let i in inputs) {
        if (inputs[i]['vdjserver:uuid']) {
            let data = await tapisIO.getMetadata(inputs[i]['vdjserver:uuid'])
                .catch(function(error) {
                    return Promise.reject(error);
                });
            if (data['statusCode'] == 404) valid = false;
            else
                config.log.info(context, 'vdjserver:uuid (' + inputs[i]['vdjserver:uuid'] + ') exists.');
        }
    }

    // simulate execution
    while(this.perform_activities(false)) {
        config.log.info(context, 'document after performing activities: ' + JSON.stringify(this, null, 2));
    }

    // check that all activities were performed
    // check that entities were used
    // check that entities were generated

    return Promise.resolve(valid);
};

